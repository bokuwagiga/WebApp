{"ast":null,"code":"var _jsxFileName = \"G:\\\\abroad uni\\\\KTU\\\\WEB\\\\myapp\\\\LAB3\\\\client\\\\src\\\\appContext.js\";\nimport React, { useState, useEffect } from \"react\";\nimport getState from \"./flux.js\";\n\n// Don't change, here is where we initialize our context, by default it's just going to be null.\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const Context = /*#__PURE__*/React.createContext(null);\n\n// This function injects the global store to any view/component where you want to use it, we will inject the context to layout.js, you can see it here:\n// https://github.com/4GeeksAcademy/react-hello-webapp/blob/master/src/js/layout.js#L35\nconst injectContext = PassedComponent => {\n  var _s = $RefreshSig$();\n  const StoreWrapper = props => {\n    _s();\n    //this will be passed as the contenxt value\n    const [state, setState] = useState(getState({\n      getStore: () => state.store,\n      getActions: () => state.actions,\n      setStore: updatedStore => setState({\n        store: Object.assign(state.store, updatedStore),\n        actions: {\n          ...state.actions\n        }\n      })\n    }));\n    useEffect(() => {\n      /**\n       * EDIT THIS!\n       * This function is the equivalent to \"window.onLoad\", it only runs once on the entire application lifetime\n       * you should do your ajax requests or fetch api requests here. Do not use setState() to save data in the\n       * store, instead use actions, like this:\n       **/\n      state.actions.getMessage(); // <---- calling this function from the flux.js actions\n    }, []);\n\n    // The initial value for the context is not null anymore, but the current state of this component,\n    // the context will now have a getStore, getActions and setStore functions available, because they were declared\n    // on the state of this component\n    return /*#__PURE__*/_jsxDEV(Context.Provider, {\n      value: state,\n      children: /*#__PURE__*/_jsxDEV(PassedComponent, {\n        ...props\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 39,\n        columnNumber: 5\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 38,\n      columnNumber: 4\n    }, this);\n  };\n  _s(StoreWrapper, \"Qi/cWfE7PDwod2mo/3C40neDDRQ=\");\n  return StoreWrapper;\n};\nexport default injectContext;","map":{"version":3,"names":["React","useState","useEffect","getState","jsxDEV","_jsxDEV","Context","createContext","injectContext","PassedComponent","_s","$RefreshSig$","StoreWrapper","props","state","setState","getStore","store","getActions","actions","setStore","updatedStore","Object","assign","getMessage","Provider","value","children","fileName","_jsxFileName","lineNumber","columnNumber"],"sources":["G:/abroad uni/KTU/WEB/myapp/LAB3/client/src/appContext.js"],"sourcesContent":["import React, { useState, useEffect } from \"react\";\nimport getState from \"./flux.js\";\n\n// Don't change, here is where we initialize our context, by default it's just going to be null.\nexport const Context = React.createContext(null);\n\n// This function injects the global store to any view/component where you want to use it, we will inject the context to layout.js, you can see it here:\n// https://github.com/4GeeksAcademy/react-hello-webapp/blob/master/src/js/layout.js#L35\nconst injectContext = PassedComponent => {\n\tconst StoreWrapper = props => {\n\t\t//this will be passed as the contenxt value\n\t\tconst [state, setState] = useState(\n\t\t\tgetState({\n\t\t\t\tgetStore: () => state.store,\n\t\t\t\tgetActions: () => state.actions,\n\t\t\t\tsetStore: updatedStore =>\n\t\t\t\t\tsetState({\n\t\t\t\t\t\tstore: Object.assign(state.store, updatedStore),\n\t\t\t\t\t\tactions: { ...state.actions }\n\t\t\t\t\t})\n\t\t\t})\n\t\t);\n\n\t\tuseEffect(() => {\n\t\t\t/**\n\t\t\t * EDIT THIS!\n\t\t\t * This function is the equivalent to \"window.onLoad\", it only runs once on the entire application lifetime\n\t\t\t * you should do your ajax requests or fetch api requests here. Do not use setState() to save data in the\n\t\t\t * store, instead use actions, like this:\n\t\t\t **/\n\t\t\tstate.actions.getMessage(); // <---- calling this function from the flux.js actions\n\t\t}, []);\n\n\t\t// The initial value for the context is not null anymore, but the current state of this component,\n\t\t// the context will now have a getStore, getActions and setStore functions available, because they were declared\n\t\t// on the state of this component\n\t\treturn (\n\t\t\t<Context.Provider value={state}>\n\t\t\t\t<PassedComponent {...props} />\n\t\t\t</Context.Provider>\n\t\t);\n\t};\n\treturn StoreWrapper;\n};\n\nexport default injectContext;\n"],"mappings":";AAAA,OAAOA,KAAK,IAAIC,QAAQ,EAAEC,SAAS,QAAQ,OAAO;AAClD,OAAOC,QAAQ,MAAM,WAAW;;AAEhC;AAAA,SAAAC,MAAA,IAAAC,OAAA;AACA,OAAO,MAAMC,OAAO,gBAAGN,KAAK,CAACO,aAAa,CAAC,IAAI,CAAC;;AAEhD;AACA;AACA,MAAMC,aAAa,GAAGC,eAAe,IAAI;EAAA,IAAAC,EAAA,GAAAC,YAAA;EACxC,MAAMC,YAAY,GAAGC,KAAK,IAAI;IAAAH,EAAA;IAC7B;IACA,MAAM,CAACI,KAAK,EAAEC,QAAQ,CAAC,GAAGd,QAAQ,CACjCE,QAAQ,CAAC;MACRa,QAAQ,EAAEA,CAAA,KAAMF,KAAK,CAACG,KAAK;MAC3BC,UAAU,EAAEA,CAAA,KAAMJ,KAAK,CAACK,OAAO;MAC/BC,QAAQ,EAAEC,YAAY,IACrBN,QAAQ,CAAC;QACRE,KAAK,EAAEK,MAAM,CAACC,MAAM,CAACT,KAAK,CAACG,KAAK,EAAEI,YAAY,CAAC;QAC/CF,OAAO,EAAE;UAAE,GAAGL,KAAK,CAACK;QAAQ;MAC7B,CAAC;IACH,CAAC,CACF,CAAC;IAEDjB,SAAS,CAAC,MAAM;MACf;AACH;AACA;AACA;AACA;AACA;MACGY,KAAK,CAACK,OAAO,CAACK,UAAU,CAAC,CAAC,CAAC,CAAC;IAC7B,CAAC,EAAE,EAAE,CAAC;;IAEN;IACA;IACA;IACA,oBACCnB,OAAA,CAACC,OAAO,CAACmB,QAAQ;MAACC,KAAK,EAAEZ,KAAM;MAAAa,QAAA,eAC9BtB,OAAA,CAACI,eAAe;QAAA,GAAKI;MAAK;QAAAe,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAAG;IAAC;MAAAH,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OACb,CAAC;EAErB,CAAC;EAACrB,EAAA,CAhCIE,YAAY;EAiClB,OAAOA,YAAY;AACpB,CAAC;AAED,eAAeJ,aAAa"},"metadata":{},"sourceType":"module","externalDependencies":[]}